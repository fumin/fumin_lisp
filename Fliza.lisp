;1
;?w --> w is a single word
;(?* ?x) --> ?x is a phrase of several words
;(?^ ?x fn) --> ?x is a phrase that satisfy the predicate "fn"
;(?? ?w list) --> ?w is a word that is a member of the list "list" 
;2
;grammatical correction to avoid answers like "you give it to I," 
;instead correct it to "you give it to me"
;3
;memorization of the topics of the correspondence's reponse
;4
;simple synonym (could not -> couldn't) and punctuation handling

(defun variable-p (x)
  "Is x a variable (a symbol beginning with '?')?"
  (and (symbolp x) (equal (char (symbol-name x) 0) #\?)))
(defconstant fail nil "Indicates pat-match failure")
(defconstant no-bindings '((t.t))
  "Indicates pat-match success, with novariables.")
(defun get-binding (var bindings)
  "Find a (variable . value) pair in a binding list."
  (assoc var bindings))
(defun binding-val (binding)
  "Get the value part of a single binding."
  (cdr binding))
(defun lookup (var bindings)
  "Get the value part (for var) from a binding list."
  (binding-val (get-binding var bindings)))
(defun extend-bindings (var val bindings)
  "Add a (var . value) pair to a binding list."
  (cons (cons var val) 
        ;;Once we add a "real" binding, 
        ;;we can get rid of the dummy no-bindings
        (if (eq bindings no-bindings)
            nil
            bindings)))
(defun pat-match (pattern input &optional (bindings no-bindings))
  "Match pattern against input i n the context of the bindings"
  (cond ((eq bindings fail) fail)
        ((variable-p pattern)
         (match-variable pattern input bindings))
        ((restricted-var-p pattern)
         (match-restricted-var pattern input bindings))
        ((eql pattern input) bindings)
        ((segment-pattern-p pattern)
         (segment-match pattern input bindings))
        ((restricted-segment-p pattern)
         (restricted-segment-match pattern input bindings))
        ((and (consp pattern) (consp input))
         (pat-match (rest pattern) (rest input)
                    (pat-match (first pattern) (first input)
                               bindings)))
         (t fail)))
(defun match-variable (var input bindings)
  "Does VAR match input? Uses (or updates) and returns bindings."
  (let ((binding (get-binding var bindings)))
    (cond ((not binding) (extend-bindings var input bindings))
          ((equal input (binding-val binding)) bindings)
          (t fail))))
(defun restricted-segment-p (pattern)
  "Is this a segment matching pattern: ((?* var predicate).pat)"
  (and (consp pattern)
       (starts-with (first pattern) '?^)))
(defun restricted-segment-match (pattern input bindings &optional (start 0)) 
  "Match the segment pattern ((?^ var predicate).pat) against input." 
  (let ((var (second (first pattern)))
        (pat (rest pattern))
        (seg-predicate (third (first pattern)))) 
    (if (null pat)
        (and (funcall seg-predicate input) (match-variable var input bindings))
    ;; We assume that pat starts with a constant
    ;; In other words, a pattern can't have 2 consecutive vars
    (let ((pos (match-pos pat input bindings :start start)))
      (if (null pos)
          fail
          (let ((b2 (pat-match 
                      pat (subseq input pos) 
                      (match-variable var (subseq input 0 pos) 
                                      bindings))))
            ;; If this match failed, try another longer one
            (if (or (eq b2 fail) (not (funcall seg-predicate (subseq input 0 pos))))
                (restricted-segment-match pattern input bindings (+ pos 1))
                b2)))))))
(defun restricted-var-p (pattern)
  (and (consp pattern)
       (eql 3 (length pattern))
       (symbolp (first pattern))
       (equal (char (symbol-name (first pattern)) 0) #\?)
       (equal (char (symbol-name (first pattern)) 1) #\?)
       (symbolp (second pattern))
       (equal (char (symbol-name (second pattern)) 0) #\?)))
(defun match-restricted-var (var input bindings)
  (unless (find input (eval (third var))) (return-from match-restricted-var fail)) 
  (let ((binding (get-binding (second var) bindings)))
    (cond ((not binding) (extend-bindings (second var) input bindings))
          ((equal input (binding-val binding)) bindings)
          (t fail))))
(defun segment-pattern-p (pattern)
  "Is this a segment matching pattern: ((?* var).pat)"
  (and (consp pattern)
       (starts-with (first pattern) '?*)))
(defun segment-match (pattern input bindings &optional (start 0))
  "Match the segment pattern ((?* var).pat) against input."
  (let ((var (second (first pattern)))
        (pat (rest pattern)))
    (if (null pat)
    (match-variable var input bindings)
    ;; We assume that pat starts with a constant
    ;; In other words, a pattern can't have 2 consecutive vars
    (let ((pos (match-pos pat input bindings :start start)))
      (if (null pos)
          fail
          (let ((b2 (pat-match 
                      pat (subseq input pos) 
                      (match-variable var (subseq input 0 pos) 
                                      bindings))))
            ;; If this match failed, try another longer one
            (if (eq b2 fail)
                (segment-match pattern input bindings (+ pos 1))
                b2)))))))
(defun match-pos (pattern input bindings &key start)
  (loop for i from start to (length input)  
        unless (eql (pat-match pattern (subseq input i) bindings) 'fail) 
          do (return-from match-pos i)))      
(defun rule-pattern (rule) (first rule))
(defun rule-responses (rule) (cddr rule))
(defun rule-memory (rule) (second rule))
(defparameter *eliza-rules*
  '((((?* ?x) hello (?* ?y)) ()
     (How do you do. Is there any problem that I can help you with?) 
     (Hello <comma> what a nice day it is today. How <apost>s everything going?) (Hello. How <apost>s your day today?))
    (((?* ?x) hi (?* ?y)) ()
     (How do you do. Is there any problem that I can help you with?) 
     (Hello <comma> what a nice day it is today. How <apost>s everything going?) (Hello. How <apost>s your day today?))
    (((?* ?x) not bad (?* ?y)) ()
     (Understood <comma> but I wonder do you really think it <apost>s not bad?) (Do you mean <colon> ?x <dquote> pretty good <dquote> ?)
     (I <apost>m not sure you meant fantastic or quite disgusting with the phrase <dquote> not bad <dquote>)
     (Could you please elaborate more on the phrase <dquote> not bad <dquote> ?))
    (((?* ?x) computer (?* ?y)) (your convictions that computers ?y)
     (Do computers worry you?) (What do you think about machines?)
     (Why do you mention computers?)
     (What do you think machines have to do with your problem?))
    (((?^ ?x no-what-when-p) weather (?^ ?y no-puncs-p) (?^ ?z start-with-punc-p)) (how you think about the fact that the weather ?y)
     (Do you like such a weather?) (I can <apost>t agree with you more that the weather ?y)
     (Yeah <comma> it <apost>t true that sometimes the weather ?y))
    (((?* ?x) name (?* ?y)) ()
     (Do you think you should be talking something other than names?) (I<squote>m sorry <comma> but I<squote>m not so interested in names))
    (((?* ?x) sorry (?* ?y)) (the situation just now when ?x sorry ?y)
     (Please don <apost>t apologize) (Apologies are not necessary)
     (What feelings do you have when you apologize?))
    (((?* ?x) I remember (?* ?y)) (you yourself and your feelings when you remember ?y)
     (Do you often think of ?y)
     (Does thinking of ?y bring anything else to mind?)
     (What else do you remember) (Why do you recall ?y right now?)
     (What in the present situation reminds you of ?y)
     (What is the connection between me and ?y))
    (((?* ?x) do you remember (?* ?y)) (what your had in mind when you asked me whether I remember ?y)
     (Did you think I would forget ?y ?)
     (Why do you think I should recall ?y now)
     (What about ?y) (You mentioned ?y))
    (((?* ?x) if (?^ ?y not-beginning-with-not-p) (?^ ?v start-with-punc-p)) (what <apost>d it be if ?y)
     (Do you really think its likely that ?y) (Do you wish that ?y) (How likely do you think that ?y)
     (What do you think about the proposition that ?y) (Really-- if ?y))
    (((?* ?x) I dreamt (?* ?y)) (when you dreamt ?y)
     (Really-- ?y) (Have you ever fantasized ?y while you were awake?)
     (Have you dreamt ?y before?))
    (((?* ?x) dream about (?* ?y)) (your dream about)
     (How do you feel about ?y in reality?))
    (((?* ?x) dream (?* ?y)) (your dream ?y)
     (What does this dream suggest to you?) (Do you dream often?)
     (What persons appear in your dreams?)
     (Don <apost>t you believe that dream has to do with your problem?))
    (((?* ?x) my (?? ?z fem-rel-restricted-list) (?* ?y)) (your ?z)
     (Your ?z) (Does she influence you strongly?) (Tell me more about your family)
     (Tell me more about your ?z)
     (What else comes to mind when you think of your ?z ?))
    (((?* ?x) my (?? ?z mas-rel-restricted-list) (?* ?y)) (your ?z)
     (Tell me more about your ?z)
     (Who else in your family ?y) (Tell me more about your family))
    (((?* ?x) my (?? ?z neu-rel-restricted-list) (?* ?y)) (your ?z)
     (Tell me more about your ?z) (Tell me more about the relationship between your ?z and the other members of your family)
     (What prompts you in thinking that your ?z ?y))
    (((?^ ?x no-what-when-p) (?? ?z man-who-wants-restricted-list) (?^ ?u no-person-p) not (?? ?w want-restricted-list) (?^ ?y something-wanted-p) (?^ ?v start-with-punc-p)) (in what way and how ?z not ?w ?y)
     (What would it mean to you if ?z really eventually did not got ?y)
     (Why would ?z not ?w ?y) (I<squote>m not so sure whether ?z did not ?w ?y))
    (((?^ ?x no-what-when-p) (?? ?z man-who-wants-restricted-list) (?^ ?u no-person-p) (?? ?w want-restricted-list) (?^ ?y something-wanted-p) (?^ ?v start-with-punc-p)) (how ?z ?w ?y)
     (What would it mean to you if ?z got ?y)
     (Why would ?z ?w ?y) (Suppose ?z got ?y soon))
    (((?* ?x) (?? ?z man-who-wants-restricted-list) (?^ ?u no-person-p) not (?? ?w want-restricted-list) (?^ ?y something-wanted-p) (?^ ?v start-with-punc-p)) (why you asked <dquote> ?x ?z ?w ?y <dquote> just now)
     (Why would ?z not ?w ?y))
    (((?* ?x) (?? ?z man-who-wants-restricted-list) (?^ ?u no-person-p) (?? ?w want-restricted-list) (?^ ?y something-wanted-p) (?^ ?v start-with-punc-p)) (why you asked <dquote> ?x ?z ?w ?y <dquote> just now)
     (Why would ?z ?w ?y))
    (((?* ?x) (?? ?z man-who-wants-restricted-list) (?^ ?u no-person-no-what-when-p) (?^ ?w cant-or-unable-p) (?^ ?y something-wanted-p) (?^ ?v start-with-punc-p)) (the reasons why you believed that ?z couldn<squote>t ?y)
     (What if in fact <comma> ?z actually could ?y) (What does the fact that ?z ?w ?y imply to you?)
     (Do you have any ideas why ?w ?z ?y) (Suppose ?z could ?y soon))
    (((?* ?x) I am glad (?* ?y)) (why you are satisfied ?y)
     (How have I helped you to be ?y) (What make you happy just now)
     (Can you explain why you are suddenly glad ?))
    (((?* ?x) I am (?? ?z sad-restricted-list) (?* ?y)) (you when you are ?z ?y)
     (I am sorry to hear you are ?z ?y)
     (I am sure it <apost>s not pleasant to be ?z ?y))
    (((?* ?x) are like (?* ?y)) (the relationships between ?x and ?y)
     (What resemblance do you see between ?x and ?y))
    (((?* ?x) is like (?* ?y)) (the way that you see that ?x and ?y are alike)
     (In what way is it that ?x is like ?y)
     (What resemblance do you?)
     (Could there really be some connection?) (How?))
    (((?* ?x) alike (?* ?y)) (the similiarities between ?x and ?y)
     (In what way?) (What similarities are there?))
    (((?* ?x) same (?* ?y)) (the way you link ?x with ?y)
     (What other connections do you see?))
    (((?* ?x) I was (?* ?y)) (how your were ?y)
     (Were you really? How was that?) (Perhaps I already knew you were ?y)
     (Why do you tell me you were ?y now?))
    (((?* ?x) was I (?* ?y)) (the time when you were ?y)
     (What if you were ?y ?) (Do you think you were ?y)
     (What would it mean if you were ?y))
    (((?* ?x) I am (?* ?y)) (both the good and bad aspects that you think <comma> reagarding the fact that you being ?y)
     (In what way are you ?y) (Do you want to be ?y ?))
    (((?* ?x) am I (?* ?y)) (the motives behind just now <comma> when you asked me that were you ?y)
     (Do you believe you are ?y) (Would you want to be ?y)
     (You wish I would tell you you are ?y)
     (What would it mean if you were ?y))
    (((?* ?x) am (?* ?y)) ()
     (Why do you say "AM?") (I don <apost>t understand that))
    (((?* ?x) are you (?? ?y prepositions-restricted-list)) (why you<squote>d like to know <dquote> ?x are you ?y<dquote>)
     (I<squote>m a little curious why are you interested in me on this aspect?))
    (((?* ?x) are you (?* ?y)) (what it means to you if I am ?y)
     (Why are you interested in whether I am ?y or not?)
     (Would you prefer if I weren <apost>t ?y)
     (Perhaps I am ?y in your fantasies))
    (((?* ?x) you are (?^ ?y no-puncs-p) (?^ ?z start-with-punc-p)) ()
     (What makes you think I am ?y ?))
    (((?* ?x) because (?* ?y)) (what was your thinking just now <comma> when you mentioned that ?x because ?y)
     (Is that the real reason?) (What other reasons might there be?)
     (Does that reason seem to explain anything else?))
    (((?* ?x) were you (?* ?y)) (the reactions you would have <comma> just now <comma> if I wasn <apost>t ?y)
     (Perhaps I was ?y) (What do you think?) (What if I had been ?y))
    (((?* ?x) I can <apost>t (?* ?y)) (what makes you think that you won <apost>t be able to ?y)
     (Maybe you could ?y now) (What if you could ?y ?))
    (((?* ?x) I feel (?* ?y)) (yourself when you feel ?y)
     (Do you often feel ?y ?))
    (((?* ?x) I felt (?* ?y)) (yourself when you felt ?y)
     (What other feelings do you have?))
    (((?* ?x) I (?^ ?y with-each-other-p) you (?* ?z)) (why you thought that ?x you ?y me ?z)
     (Perhaps in your fantasy we ?y each other))
    (((?* ?x) why don <apost>t you (?* ?y)) (what <apost>d you do should I ?y)
     (Should you ?y youself?)
     (Do you believe I don <apost>t ?y) (Perhaps I will ?y in good time))
    (((?* ?x) (?? ?y means-restricted-list) (?* ?z)) (what you think about the assertion that ?x ?y ?z)
     (Share with me the reasons why you think the statement <dquote> ?x ?y ?z <dquote> is true or not true) (Do you <apost>ve any clues of why ?x ?y ?z ?)
     (What will be your reaction if i tell you that i don <apost>t think the statement <dquote> ?x ?y ?z <dquote> is valid))
    (((?* ?x) (?? ?z man-who-wants-restricted-list) (?^ ?u no-person-p) (?? ?w have-restricted-list) (?^ ?y something-wanted-p) (?^ ?v start-with-punc-p)) (the way you see the fact that ?z ?w ?y)
     (In your opinion <comma> What does the fact ?z ?w ?y mean to ?z)
     (How does the fact that ?z ?w ?y affect you?) (How sure are you about your claims that ?z ?w ?y))
    (((?* ?x) someone (?* ?y)) (your feelings when you described that ?x someone ?y)
     (Can you be more specific?) (Please elaborate more on the person ?y)
     (Can you give me a better idea of the person ?y <comma> that you were intending to talk about?))
    (((?* ?x) something (?* ?y)) (your feelings when you described that ?x something ?y)
     (Can you be more specific?) (Please elaborate more on the thing ?y <comma> that you intend to talk about) 
     (Can you give me a better idea of the thing ?y <comma> that you were intending to talk about?))
    (((?* ?x) sometimes (?* ?y)) (your feelings when you described that ?x sometimes ?y)
     (Please elaborate more on the particular occassions that you intend to talk about) 
     (how often if sometimes?) (Can you give me a better idea of the time interval of sometimes?))
    (((?* ?x) everyone (?* ?y)) (what makes you guess that ?x everyone ?y)
     (Surely not everyone) (Can you think of anyone in particular?)
     (Who for example?) (You are thinking of a special person))
    (((?* ?x) nobody (?* ?y)) (what makes you guess that ?x nobody ?y)
     (Surely there <apost>s someone) (perhaps ?x someone ?y)
     (Do you really mean completely <dquote> no one <dquote> ?))
    (((?* ?x) never (?* ?y)) (what makes you guess that ?x never ?y)
     (Surely not never) (perhaps there are some exceptions to never?) (Never say never)
     (Do you really mean completely <dquote> never <dquote> ?))
    (((?* ?x) everything (?* ?y)) (what makes you guess that ?x everything ?y)
     (Surely not everything) (Can you think of anything in particular?)
     (What thing for example?) (You are thinking of a special object <comma> event <comma>> or concept))
    (((?* ?x) (?? ?z always-restricted-list) (?* ?y)) (the reasons you think why ?x ?z ?y)
     (Can you think of a specific example) (When?)
     (What particular incident are you thinking of?) (Really-- ?z ?))
    (((?* ?x) nothing (?* ?y)) (what makes you guess that ?x nothing ?y)
     (Surely not completely nothing) (perhaps ?x something ?y)
     (Do you really mean <dquote> nothing <dquote> ?))
    (((?* ?x) what (?* ?y)) (what do you think the answer would be to the question <colon> <dquote> what ?y <dquote> you mentioned just now)
     (Why do you ask?) (Does that question interest you?)
     (What is it you really want to know?) (What do you think?)
     (What comes to your mind when you ask that?))
    (((?* ?x) perhaps (?* ?y) (?^ ?v start-with-punc-p)) (what you think the outcomes would be if ?y)
     (You do not seem quite certain) (I wonder how high the chances are for the statement <dquote> ?y <dquote> to become true))
    (((?* ?x) well <comma> (?* ?y)) (what you intended to express when you said <colon> ?y)
     (?y) (Assuming that ?y <comma> what <apost>s your next step) (Understood<comma> but there <apost>re also chances that the claim that <comma> ?y <comma> is not ture))
    (((?* ?x) yes (?* ?y)) ()
     (You seem quite positive) (You are sure) (Yes <comma> I understand))
    (((?* ?x) no (?* ?y)) ()
     (Why not?) (You are being a bit negative)
     (Are you saying "NO" just to be negative?))
    (((?^ ?x no-what-when-and-puncs-p) (?? ?y do-by-people-verbs-list) (?* ?z) (?^ ?v start-with-punc-p)) (the the statement <dquote> ?x ?y ?z <comma> <dquote> you mentioned just now)
     (Oh <comma> ?x ?y ?z <period>) (What happened next?) (And then) (I did<squote>t know that) (But why?) (Please go on)
     (OK <comma> suppose ?x ?y ?z) (Are you sure?)) 
    (((?^ ?x no-what-when-no-not-p) good (?* ?y)) ()
     (OK <comma> that<squote>s great) (How good is good?) (Yes <comma> I suppose you mean pretty nice ))
    (((?^ ?x no-what-when-p) good (?* ?y)) ()
     (Do you mean bad for not good?) (How is it so?) (OK <comma> I agree it<squote>s not that good))
    (((?^ ?x no-what-when-no-not-p) bad (?* ?y)) ()
     (OK <comma> too bad) (How bad is bad?) (Ur <comma> I suppose you mean disgusting or pathetic))
    (((?^ ?x no-what-when-p) bad (?* ?y)) ()
     (OK <comma> you mean pretty good?) (Not bad?) (Yeah <comma> I agree with you <comma> quite nice and not very bad))
    (((?^ ?x no-what-when-p) my (?^ ?z no-puncs-p) (?^ ?w start-with-punc-p)) (why you mentioned that ?x your ?z)
     (What do you mean by <dquote> your ?z <dquote> ?) (I wonder why <dquote> your ?z <dquote> ?))
    (((?^ ?x no-what-when-p) your (?^ ?z no-puncs-p) (?^ ?w start-with-punc-p)) (why you mentioned that ?x my ?z)
     (What do you mean by <dquote> my ?z <dquote> ?) (Why <dquote> me <dquote> ?) (I wonder why my ?z ?))
    (((?^ ?x no-what-when-p) (?? ?y belonging-pronoun-restricted-list) (?^ ?z no-puncs-p) (?^ ?w start-with-punc-p)) (why you mentioned that <colon> ?x <dquote> ?y <dquote> ?z)
     (Who are you refering to in particular by saying ?y ?) (What do you mean by <dquote> ?y ?z <dquote> ?) (Why <dquote> ?y <dquote> ?) (I wonder why ?y ?z ?))
    (((?^ ?x no-what-when-p) I (?^ ?z no-puncs-and-sth-p) (?^ ?w start-with-punc-p)) (why you mentioned that ?x you ?z)
     (What do you mean by <dquote> you ?z <dquote> ?) (Why <dquote> you <dquote> ?) (I wonder why you ?z ?)
     (Perhaps you didn <apost>t))
    (((?^ ?x no-what-when-p) you (?^ ?z no-puncs-and-sth-p) (?^ ?w start-with-punc-p)) (why you mentioned that ?x I ?z)
     (What do you mean by <dquote> I ?z <dquote> ?) (Why <dquote> me <dquote> ?) (I wonder why I ?z ?)
     (Perhaps I didn <apost>t))
    (((?^ ?x no-what-when-p) (?? ?y subject-pronoun-restricted-list) (?^ ?z no-puncs-and-sth-p) (?^ ?w start-with-punc-p)) (why you mentioned that <colon> ?x <dquote> ?y <dquote> ?z)
     (Which ?y are you refering to?) (What do you mean by <dquote> ?y ?z <dquote> ?) (Why <dquote> ?y <dquote> ?) (I wonder why ?y ?z ?)
     (Perhaps ?y didn <apost>t))
    (((?^ ?x no-what-when-and-puncs-p) are (?* ?y)) (the ideas you have <comma> to account for the fact that ?x are ?y)
     (Did you think they might not be ?y)
     (Possibly they are ?y))
    (((?^ ?x no-puncs-p) (?? ?y prepositions-restricted-list) (?^ ?z something-wanted-p) (?^ ?v start-with-punc-p)) (why you mentioned that <colon> ?x <dquote> ?y <dquote> ?z)
     (Why <dquote> ?y <dquote> ?z ?) (What do you mean by <dquote> ?y <dquote> ?z ?) (What if it turns out that ?x <dquote> not ?y <dquote> ?z ?))    
    (((?* ?x) goodbye (?* ?y)) ()
     (Goodbye!))))
(defun fliza ()
  "Respond to user input using pattern matching rules."
  (loop
    (print 'fliza>)
    (when (equalp "Goodbye!" (eliza-write (flatten (use-eliza-rules (eliza-read))) :pretty t)) (return 'eliza))))
(defun use-eliza-rules (input)
  "Find some rule with which to transform the input."
  (some #'(lambda (rule)
             (let* ((result (switch-viewpoint (pat-match (rule-pattern rule) input))) 
                    (to-be-memorized (sublis result (rule-memory rule))))
               (cond ((not (eq result fail))
                      (unless (null to-be-memorized) (push to-be-memorized *eliza-memory*))
                      (sublis result
                              (random-elt (rule-responses rule)))))))
        *eliza-rules*))
(defun switch-viewpoint (words)
  "Change I to you and vice versa, and so on."
  (sublis '((I . you) (you . I) (me . you) (am . are) (my . your) (mine . yours) (your . my) (yours . mine))
          words))
(defun flatten (the-list)
  "Append together elements (or lists) in the list."
  (mappend #'mklist the-list))
(defun mklist (x)
  "Return x if it is a list, otherwise (x)."
  (if (listp x)
      x
      (list x)))
(defun random-elt (choices)
  "choose an element from a list at random."
  (elt choices (random (length choices))))
(defun eliza-write (object &key pretty)
  (let ((s (eliza-punc-substitute (write-to-string object :pretty pretty) 'write)) memory deleted-mem)
    (when (equalp "nil" s)
          ;;; when no pattern matches, 50% chances to speak equivocally, 50% chances to say "tell me more about..."
          (when (eql 1 (random 2)) (return-from eliza-write (write (list-to-string (random-elt eliza-equivocal-rhetoric)) :escape nil :pretty t)))
          (when (null *eliza-memory*) (return-from eliza-write (format t "PLEASE TELL ME MORE ABOUT YOURSELF, YOUR WORK, YOUR FAMILY, AND YOUR LIFE"))) 
          (setf memory (eliza-punc-substitute (write-to-string (flatten (setf deleted-mem (random-elt *eliza-memory*))) 
                                                          :pretty pretty) 
                                                  'write))
          (setf *eliza-memory* (remove deleted-mem *eliza-memory* :test #'equalp))
          (return-from eliza-write (format t "TELL ME MORE ABOUT ~a" (eliminate-punc-spaces (grammer-I-to-me (subseq memory 1 (- (length memory) 1)))))))
    (write (eliminate-punc-spaces (grammer-I-to-me (subseq s 1 (- (length s) 1)))) :escape nil :pretty pretty)))
(defvar *eliza-memory* nil "Eliza's memory of the correspondence's own conceded facts")
(defconstant r-punctuation-subst-list
  '((" <comma>" . #\,)
    (" <colon>" . #\:)
    (" <blash>" . #\\)
    (" <sharp>" . #\#)
    ("<dquote>" . #\")
    ("<squote>" . #\')
    (" <period>" . #\.)
    (" <qmark>" . #\?)
    (" <exmark>" . #\!)
    (" <scolon>" . #\;)
    (" <apost>" . #\')))
(defconstant w-punctuation-subst-list
  '((" <comma>" . #\,)
    (" <colon>" . #\:)
    (" <blash>" . #\\)
    (" <sharp>" . #\#)
    ("<dquote>" . #\")
    ("<squote>" . #\')
    (" <period>" . #\space)
    (" <qmark>" . "")
    (" <exmark>" . "")
    (" <scolon>" . #\space)
    (" <backspace>" . "")
    (" <apost>" . #\')))
(defun eliza-punc-substitute (str direction)
  (if (equal 'write direction)
      (dolist (x w-punctuation-subst-list)
        (setf str (str-substitute (cdr x) (car x) str :test #'equalp)))
      (dolist (x r-punctuation-subst-list)
        (setf str (str-substitute (car x) (cdr x) str :test #'equalp))))
  str)
(defun eliza-read ()
  (let (s)
    (setf s (eliza-punc-substitute (synonyms (read-line)) 'read))
    (read-from-string
      (concatenate 'string "(" (substitute-if #\space #'punctuation-p
                                              s)
                            ")"))))
(defun punctuation-p (c) (find c "(){}[]"))
(defun synonyms (input)
  (dolist (x synonyms-list)
    (setf input (str-substitute (car x) (cdr x) input :test 'equalp)))
  (setf input (str-substitute "can't" "cannot" input :test 'equalp))
  (setf input (str-substitute "couldn't" "could not" input :test 'equalp))
  input)
(defconstant synonyms-list
  '(("computer" . "computers")
    ("everyone" . "everybody")
    ("someone" . "somebody")
    ("sorry" . "sorried")
    ("perhaps" . "maybe")
    ("remember". "remembered")
    (" are" . "'re")
    (" will" . "'ll")
    ("I am" . "I'm")
    ("something" . "sth")
    (" you " . " u ")
    (" hello" . " hi")
    ("cannot" . "can't")
    (" have" . "'ve")
    ("will not" . "won't")
    (" want to " . " wanna ")
    (" got to " . " got to ")
    ("goodbye" . "byebye")
    ("goodbye" . "good bye")
    (" not" . "n't")))
(defconstant fem-rel-restricted-list
  '(mother grandmother sister aunt auntie))
(defconstant mas-rel-restricted-list
  '(father grandfather brother uncle))
(defconstant neu-rel-restricted-list
  '(cousin nephew))
(defconstant sad-restricted-list
  '(sad depressed unhappy)) 
(defconstant want-restricted-list
  '(want need wants needs wanted needed))
(defconstant have-restricted-list
  '(have has had))
(defconstant means-restricted-list
  '(mean means meant))
(defconstant man-who-wants-restricted-list
  '(i you he she they we it))
(defconstant subject-pronoun-restricted-list
  '(he she they we it i you))
(defconstant belonging-pronoun-restricted-list
  '(his her their our its my your))
(defconstant always-restricted-list
  '(everytime always))
(defconstant prepositions-restricted-list
  '(at below on beneath above in behind across between from throughout for inside under beside underneath outside after aboard 
    against along alongside amid amidst among around atop before beyond within up down right left plus minus near far onto opposite 
    out over towards toward with))
(defconstant do-by-people-verbs-list
  '(say said says think thought thinks tell tells told speak speaks spoke see sees saw believe believes believed
    feel feels felt ))
(defun no-person-p (input)
  (not (intersection input man-who-wants-restricted-list :test 'equalp)))
(defun with-each-other-p (input)
  (or (eql 1 (length input))
      (find (first (last input)) prepositions-restricted-list))) 
(defun no-what-when-and-puncs-p (input)
  (and (no-what-when-p input)
       (no-puncs-and-sth-p input)))
(defun something-wanted-p (input) 
  (> (length input) 0))
(defun no-what-when-no-not-p (input)
  (and (no-what-when-p input)
       (not (find 'not input))))
(defun no-puncs-and-sth-p (input)
  (and (no-puncs-p input)
       (something-wanted-p input)))
(defun start-with-punc-p (input)
  (or (find (first input) '(<comma> <colon> <period> <exmark> <qmark> <scolon>))
      (eql 0 (length input))))
(defun end-with-punc-p (input)
  (or (find (first (last input)) '(<comma> <colon> <period> <exmark> <qmark> <scolon>))
      (eql 0 (length input))))
(defun no-puncs-p (input)
  (or (not (find '(<comma> <colon> <period> <exmark> <qmark> <scolon>) input))
      (eql 0 (length input))))
(defun no-what-when-p (input)
  (not (intersection input '(what when how why who) :test 'equalp)))
(defun no-person-no-what-when-p (input)
  (and (no-what-when-p input)
       (no-person-p input)))
(defun not-beginning-with-not-p (input)
  (not (equal (first input) 'not)))
(defun cant-or-unable-p (input)
  (or (equalp input '(can<squote>t))
      (equalp input '(couldn<squote>t))
      (equalp input '(are unable to))
      (equalp input '(am unable to))
      (equalp input '(is unable to))
      (equalp input '(were unable to))
      (equalp input '(was unable to))
      (equalp input '(failed to))))
(defun grammer-I-to-me (str)
  (let* (me-punc i-punc
         (i-prep-list 
          (mapcar #'(lambda (x) 
                      (let (s) (setf s (write-to-string (list 'i x))) 
                               (setf s (subseq s 1 (- (length s) 1)))
                               (concatenate 'string " " s " "))) 
                  (append '(to of) prepositions-restricted-list)))
         (i-qprep-list
          (mapcar #'(lambda (x) 
                      (let (s) (setf s (write-to-string x))
                               (setf s (concatenate 'string " i \" " (write-to-string x) " \"")))) 
                  (append '(to of) prepositions-restricted-list)))
         (prep-i-list 
          (mapcar #'(lambda (x) 
                      (let (s) (setf s (write-to-string (list x 'i))) 
                               (setf s (subseq s 1 (- (length s) 1)))
                               (concatenate 'string " " s " "))) 
                  (append '(to of not) prepositions-restricted-list)))
         (qprep-i-list
          (mapcar #'(lambda (x) 
                      (let (s) (setf s (write-to-string x))
                               (setf s (concatenate 'string "\" " (write-to-string x) " \" i "))))
                  (append '(to of not) prepositions-restricted-list)))
         (iprepi-list (append prep-i-list i-prep-list i-qprep-list qprep-i-list)))
    (dolist (x iprepi-list)
      (setf str (str-substitute (str-substitute " ME " " i " x :test 'equalp)
                                x str :test 'equalp)))
    (dolist (x '(" ," " ." " !" " ?" " :" " ;" " \" ." " \" ," " \" !" " \" ?" " \" :" " \" ;"))
      (setf me-punc (concatenate 'string " ME" x))
      (setf i-punc (concatenate 'string " I" x))
      (setf str (str-substitute me-punc i-punc str :test 'equalp))) 
    (setf str (str-substitute " I AM " " i are " str :test 'equalp))
    (when (eql (- (length str) 2) (search " i" str :test 'equalp :from-end t)) (setf str (concatenate 'string (subseq str 0 (- (length str) 2)) " ME")))
    (grammer-we-to-us str)))
(defun grammer-we-to-us (str)
  (let* (us-punc we-punc
         (i-prep-list 
          (mapcar #'(lambda (x) 
                      (let (s) (setf s (write-to-string (list 'we x))) 
                               (setf s (subseq s 1 (- (length s) 1)))
                               (concatenate 'string " " s " "))) 
                  (append '(to of) prepositions-restricted-list)))
         (i-qprep-list
          (mapcar #'(lambda (x) 
                      (let (s) (setf s (write-to-string x))
                               (setf s (concatenate 'string " we \" " (write-to-string x) " \"")))) 
                  (append '(to of) prepositions-restricted-list)))
         (prep-i-list 
          (mapcar #'(lambda (x) 
                      (let (s) (setf s (write-to-string (list x 'we))) 
                               (setf s (subseq s 1 (- (length s) 1)))
                               (concatenate 'string " " s " ")))
                  (append '(to of not) prepositions-restricted-list)))
         (qprep-i-list
          (mapcar #'(lambda (x) 
                      (let (s) (setf s (write-to-string x))
                               (setf s (concatenate 'string "\" " (write-to-string x) " \" we "))))
                  (append '(to of not) prepositions-restricted-list)))
         (iprepi-list (append prep-i-list i-prep-list i-qprep-list qprep-i-list)))
    (dolist (x iprepi-list)
      (setf str (str-substitute (str-substitute " US " " we " x :test 'equalp)
                                x str :test 'equalp)))                          
    (dolist (x '(" ," " ." " !" " ?" " :" " ;" " \" ." " \" ," " \" !" " \" ?" " \" :" " \" ;"))
      (setf us-punc (concatenate 'string " US" x))
      (setf we-punc (concatenate 'string " WE" x))
      (setf str (str-substitute us-punc we-punc str :test 'equalp)))
    (when (eql (- (length str) 3) (search " we" str :test 'equalp :from-end t)) (setf str (concatenate 'string (subseq str 0 (- (length str) 3)) " US")))
    str))
(defconstant eliza-equivocal-rhetoric
  '((Very interesting) (I'm not sure I understand you fully) (What happened next?) (And then)
    (What does that suggest to you?) (Please continue) (Go on)))
(defun eliminate-punc-spaces (str)
  (dolist (x eliminate-punc-spaces-list)
    (setf str (str-substitute (cdr x) (car x) str :test 'equalp)))
  str)
(defconstant eliminate-punc-spaces-list
  '((" ," . #\,)
    (" :" . #\:)
    (" ." . #\.)
    (" ?" . #\?)
    (" !" . #\!)
    (" '" . #\')
    (" ;" . #\;)))
(defun str-substitute (new old s &key from-end test test-not (start 0) end count key)
  (when (equal new old) (return-from str-substitute s))
  (let (p (old-length (if (stringp old) (length old) 1)))
    (if (null (setf p (if (stringp old)
			  (search old s :from-end from-end
				        :test test
					;;;:test-not test-not
					:start2 start
					:end2 end)
			  (position old s :from-end from-end
				          :test test
					  ;;;:test-not test-not
					  :start start
					  :end end))))
	s
	(str-substitute new old
			(concatenate 'string
				     (subseq s 0 p)
				     (if (stringp new) new (string new))
				     (subseq s (+ p old-length)))
			:from-end from-end
			:test test
			;;;:test-not test-not
			:start p
			:end (+ (if (null end) (length s) end) (- (if (stringp new) (length new) 1) old-length))
			:count (if (numberp count) (- count 1) nil)))))

(defun starts-with (list x)
  "Is this a list whose first element is x?"
  (and (consp list) (eql (first list) X)))

(defun list-to-string (l)
  (let ((str (write-to-string l :pretty t)))
    (subseq str 1 (- (length str) 1))))